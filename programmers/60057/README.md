
### 풀이 생각
1. slice 하는 개수 n을 (0 ~ 전체 길이 절반) 반복
2. string s를 index + n으로 훑으며 반복되는 문자를 탐색

### 풀이
코드 흐름
- 1차 루프: slice 크기 n을 `0 ~ s.length() / 2` 반복 (++n)
- 2차 루프: index i를 `0 ~ s.length() - n` 반복 (n + 1씩 증가)
- 직전 string과 현재 i부터 자른 새로운 조각을 비교 (직전 조각 compare 새로운 조각)
  - 같으면 `++Count` 후 2차 루프 진행
  - 다르면 string append 후 새로운 조각으로 2차 루프 진행
- 2차 루프 종료 시, 현재 최소 길이 문자열과 길이 비교하여 저장
  - n 1 증가 후 1차 루프 반복

### 아쉬운 점
문제에서는 무조건 n만큼 조각을 내야했다.  
(예를 들어, xabcabc의 경우 x2abc는 불가능하다.)  
이 점을 뒤늦게 확인했다.  

또 c++의 substr은 `substr(시작 위치, 크기)`인데, 두 매개변수를 모두 인덱스로 하는 java처럼 생각한게 시간을 많이 뺏었다..!